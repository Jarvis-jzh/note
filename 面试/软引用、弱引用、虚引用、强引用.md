## 强引用

只要还被引用，就不会被 GC 回收

```java
/**
 * @author jzh
 * @version 1.0.0
 * @date 2020/4/7 13:35
 * @description 强引用：只要还有引用，就宁愿 OOM 也不回收
 */
public class StrongRefDemo {

    /**
     * strongRef 是静态变量，只有 StrongRefDemo 类销毁的时候，才能销毁
     * 而类只有当进程销毁的时候才会被销毁
     */
    static Object strongRef = new Object();

    public static void main(String[] args) {
        demo1();
        demo2();
    }

    public static void demo1() {
        System.out.println("demo1");
        Object obj = strongRef;
        // 虽然这里将 strongRef 设置为 null，但因为被强引用，所以 GC 后不会被回收
        strongRef = null;
        System.gc();
        System.out.println("GC 之后：" + obj);
        System.out.println("GC 之后：" + strongRef);
    }

    public static void demo2() {
        System.out.println("demo2");
        Object strongRef2 = new Object();
        Object obj = strongRef2;
        // 虽然这里将 strongRef2 设置为 null，但因为被 obj 强引用，所以 GC 后不会被回收
        strongRef2 = null;
        System.gc();
        System.out.println("GC 之后：" + obj);
        System.out.println("GC 之后：" + strongRef2);
    }
}
```



## 软引用

软引用只有在设置为 null 或者内存不足时才会被回收，还有在一定时间内没有被使用也会进行回收

```java
/**
 * @author jzh
 * @version 1.0.0
 * @date 2020/4/7 14:01
 * @description 软引用
 */
public class SoftRefDemo {
    /**
     * 软引用和强引用的区别：
     * 软引用和强引用都是在内存充足的情况下不会被回收
     * 软引用在内存不足的情况下，为避免 OOM 会进行回收，但强引用是宁愿 OOM 也不会进行回收
     *
     * @param args
     * @throws InterruptedException
     */
    public static void main(String[] args) throws InterruptedException {
        Object softRef = new Object();
        // 在自动回收的情况下，只有在程序发生 OOM 异常前才会被回收
        SoftReference softReference = new SoftReference(softRef);
        softRef = null;
        System.out.println(softReference.get());
        System.out.println(softRef);
        System.gc();
        System.out.println(softReference.get());
        System.out.println(softRef);
    }
}
```



## 强引用和软引用的区别

相同：在内存充足的情况下都不会被回收

不同：当内存不足的时候，强引宁愿 OOM 也不回收，而软引用为了避免 OOM 会进行回收



## 弱引用

当对象没有被使用的下一次 GC 才会被回收

```java
/**
 * @author jzh
 * @version 1.0.0
 * @date 2020/4/7 14:52
 * @description 弱引用：当对象没有被使用的下一次 GC 才会被回收
 */
public class WeakRefDemo {
    public static void main(String[] args) {
        demo1();
        System.out.println("------------------------");
        demo2();
        System.out.println("------------------------");
        demo3();
        System.out.println("------------------------");
        demo4();
    }

    public static void demo1() {
        Object weakObj = new Object();
        WeakReference weakReference = new WeakReference(weakObj);
        System.gc();
        System.out.println("GC 之后，null 之前：" + weakReference.get());
        weakObj = null;
        System.out.println("GC 之前，null 之后：" + weakReference.get());
        System.gc();
        System.out.println("GC 之后，null 之后：" + weakReference.get());
    }


    /**
     * 注意：
     * String str = "hello weak ref";
     * 这个变量的值是存放在字符串常量池里的，而 GC 是不会清理常量池里的内容的
     */
    public static void demo2() {
        String str = "hello weak ref";
        WeakReference weakReference = new WeakReference(str);
        str = null;
        System.out.println("GC 之前：" + weakReference.get());
        System.gc();
        System.out.println("GC 之后：" + weakReference.get());
    }

    /**
     * 注意：
     * 这里的 str 是通过 new 来构造对象的，这意味着 str 引用的对象是存放在堆里的，所以可以被 GC 清理掉
     */
    public static void demo3() {
        String strObj = new String("hello weak ref");
        WeakReference weakReference = new WeakReference(strObj);
        strObj = null;
        System.out.println("GC 之前：" + weakReference.get());
        System.gc();
        System.out.println("GC 之后：" + weakReference.get());
    }

    public static void demo4() {
        String str = "hello weak ref";
        String strObj = new String("hello weak ref");
        String strObj2 = new String(str);
        String strObj3 = strObj;
        String str3 = str;
        System.out.println(str == strObj);              // false
        System.out.println(strObj == strObj2);          // false
        System.out.println(strObj2 == str);             // false
        System.out.println(strObj3 == strObj);          // true
        System.out.println(str3 == str);                // true
    }
}
```



## 软引用和弱引用的区别

不同：软引用只有当内存不足、被引用对象为 null 或者一定时间内没有被引用时才会被回收；而弱引用只有当没被使用的时候，会在下一次 GC 被回收



## 虚引用

使用的情况比较少，一般在对象回收前进行处理使用。

phantomReference.get() 本身无论如何都是 null，只有当对象将要被回收前，会将对象放入到 ReferenceQueue 队列中，我们可以通过 ReferenceQueue 队列获取到即将回收的对象用于做其它处理。

```java
/**
 * @author jzh
 * @version 1.0.0
 * @date 2020/4/7 15:31
 * @description 虚引用：使用得比较少，一般用在对象被回收前对该对象进行操作
 */
public class PhantomRefDemo {
    public static void main(String[] args) throws InterruptedException {
        ReferenceQueue queue = new ReferenceQueue();
        Object phantomObj = new Object();
        PhantomReference phantomReference = new PhantomReference(phantomObj, queue);
        System.out.println(phantomReference.get());

        phantomObj = null;
        System.out.println("GC 前：" + phantomReference.get());
        System.out.println("GC 前：" + queue.poll());
        System.gc();
        System.out.println("GC 后：" + phantomReference.get());
        System.out.println("GC 后：" + queue.poll());
        Thread.sleep(200);
        System.out.println("睡眠后：" + phantomReference.get());
        System.out.println("睡眠后：" + queue.poll());
    }
}
```

