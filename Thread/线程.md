# 线程创建

## 1、继承Tread+run()

启动：创建子类对象+对象。start()

## 2、实现Runable+run(）...接口

启动：使用静态方法

![1553084622959](assets/1553084622959.png)



​	1、创建真实角色 user

​	2、创建代理角色 Thread+应用  。代理角色等于Thread th =new thread(user)，，，，代理角色帮真实角色做事

​	3、代理角色   .start()  方法来代理运行

![1553084586219](assets/1553084586219.png)

## 推荐使用接口：

1、避免单继承 局限性

2、便于共享资源

## 了解

![1553086991123](assets/1553086991123.png)



​		![1553087207429](assets/1553087207429.png)



# 线程状态

**![1553087295281](assets/1553087295281.png)**

 ![1576058488220](assets/1576058488220.png)

1、新生状态 2、就绪状态 3、运行状态 4、阻塞状态  5、死亡状态

![1576058400390](assets/1576058400390.png)



1、当new一个线程对象，就会进入新生状态，一旦进行新生状态，每个线程有它自己独立的内存工作空间，通过与主存进行交互。

2、当调用start()方法时，该线程就会进入就绪状态，进入就绪状态不代表立即调度到运行状态，而是等待CPU的调度。当进入就绪状态，代表该线程具备了运行的能力，处于就绪队列中，等待系统为其分配CPU。

> 一般有4种情况会进入就绪状态
>
> 1、调用start()方法
>
> 2、阻塞状态解除
>
> 3、调用yield()方法
>
> 4、JVM本身将CPU从本地线程切换到其它线程，则此线程就会进入就绪状态

3、当系统选定了一个等待执行的线程状态对象后，该线程才会进入运行状态。一旦获得CPU，线程才真正能执行线程体的代码，调用我们的run()方法。

4、进入阻塞状态同样有4种情况

> 1、sleep（延时，占用资源）
>
> 2、wait（和sleep不同，不占用资源）
>
> 3、join（加入、插队，等待别人用完才能用）
>
> 4、read write等IO操作

5、死亡状态

> 1、代码执行完，正常结束
>
> 2、该线程被强制终止（stop，destroy）



## 线程方法

![1576062732357](assets/1576062732357.png)



## 停止线程

1.自然终止：线程体正常执行完毕

2.外部干涉：

​	1）线程类中 定义 线程体使用的标志

​	2）线程体使用该标志

​	3）提供对外的方法改变标识

​	4)外部根据条件调用该方法即可

![1553128327616](assets/1553128327616.png)





## 阻塞

1.join：合并线程

2.yield:暂停自己的线程，静态方法

3.sleep：休眠，不会释放锁

​	1）与时间相关

​	2）模拟网络延时



# 基本信息

![1553131721028](assets/1553131721028.png)

# 线程的同步：并发

多个线程访问同一份资源，确保资源安全----------->线程安全         synchronize--->同步       ==钥匙，拥有它才能开门



一、同步块

synchronized（引用类型 | this |  类.class）{

​	}

锁定范围要正确

锁定资源要正确![1553137113816](assets/1553137113816.png)

二、同步方法

synchronized

三、死锁：过多的同步容易造成死锁



四、生产者和消费者模式

一个场景，共同的资源

1.信号灯法：

wait():等待，释放锁

sleep 不释饭锁

notify()/notifyall():唤醒，与synchronize一起使用

pic是生产物

flag是灯

movie是资源

![1553137288394](assets/1553137288394.png)





# 调度

![1553137433595](assets/1553137433595.png)



![1553137955033](assets/1553137955033.png)



schedule的参数

（调度的内容，在什么时间点调度，隔多少时间调度一次）两个参数则只调度一次

``` java
  public static void main(String[] args){
        Timer timer =new Timer();
        timer.schedule(
        new TimerTask(){
            @Override
            public void run() { System.out.println("so easy.......");}
        },
        new Date(System.currentTimeMillis()+1000),
                200                             
        );

```

# 总结



![1553138605334](assets/1553138605334.png)





![1553138621735](assets/1553138621735.png)



![1553138652188](assets/1553138652188.png)

