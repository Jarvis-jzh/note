# 线程协作

> 生产者消费者模式（模型）
>
> BIO服务器模式
>
> 科普：
>
> - PV
>   - PageView(每个页面的访问量)
> - UV
>   - UniqueVisitor(独立访问用户量)
> - VV
>   - VisitView(访问量)



## 线程通信

### 应用场景：生产者和消费者问题

- 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费；
- 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止；
- 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。

**分析：**这是一个线程同步问题，生产者和消费者共享同一个资源，生产者和消费者之间相互依赖，互为条件

- 对于生产者，没有生产产品之前 ，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费；
- 对于消费者，在消费之后 ，要通知生产者已经消费结束，需要继续生产新产品以供消费；
- 在生产者消费者问题中，仅有 synchronized 是不够的
  - synchronized 可以阻止并发更新同一个共享资源，实现了同步
  - synchronized 不能用来实现不同线程之间的消息传递（通信）



### 解决方式1

并发协作模型“生产者消费者模式” -> 管程法

![image-20191216155530763](%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C.assets/image-20191216155530763.png)

- 生产者：负责生产数据的模块（这里模块可以是：方法、对象、线程、进程）；
- 消费者：负责处理数据的模块（这里模块可以是：方法、对象、线程、进程）；
- 缓冲区：消费者不能直接使用生产者的数据，它们之间有个“缓冲区”；

生产者将生产好的数据放入“缓冲区”，消费者从“缓冲区”拿要处理的数据。



### 解决方式2

并发协作模型“生产者消费者模式” -> 信号灯法



### 注意

**Java提供了3个方法解决线程之间的通信问题**

| 方法名                        | 作用                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| final void wait()             | 表示线程一直等待，直到其它线程通知，与sleep不同，会释放锁    |
| final void wait(long timeout) | 指定等待的毫秒数                                             |
| final void notifiy()          | 唤醒一个处于等待状态的线程                                   |
| final void notifiyAll()       | 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 |

**均是java.lang.Object类的方法，都只能在同步方法或者同步块中使用，否则会抛出异常**



### 线程的生命周期

![image-20191216155942626](%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C.assets/image-20191216155942626.png)